// Generated by the Freon Language Generator.
import {
    FreNode,
    Box,
    GridCellBox,
    LabelBox,
    SvgBox,
    GridBox,
    createDefaultExpressionBox,
    ActionBox,
    FreLanguage,
    FRE_BINARY_EXPRESSION_LEFT,
    FRE_BINARY_EXPRESSION_RIGHT,
    HorizontalListBox,
    FreProjection,
    FreTableDefinition,
    TableRowBox,
    HorizontalLayoutBox,
    MultiLineTextBox,
    BoxFactory,
    BoxUtil,
    NumberDisplay,
    TextBox,
    DiagramBox, BoolDisplay, FreNodeReference, FreProjectionHandler, DiagramEdge
} from "@freon4dsl/core";
import { Documentation, Entity, ExampleUnit, NumberLiteralExpression, OrExpression, SumExpression } from "../language/gen/index.js";
import { ExampleEnvironment } from "../config/gen/ExampleEnvironment.js";

const sumIcon = "M 6 5 L 6.406531 20.35309 L 194.7323 255.1056 L 4.31761 481.6469 L 3.767654 495.9135 L 373 494 C 376.606 448.306 386.512 401.054 395 356 L 383 353 C 371.817 378.228 363.867 405.207 340 421.958 C 313.834 440.322 279.304 438 249 438 L 79 438 L 252.2885 228.6811 L 96.04328 33.3622 L 187 32.99999 C 245.309 32.99999 328.257 18.91731 351.329 89.00002 C 355.273 100.98 358.007 113.421 359 126 L 372 126 L 362 5 L 6 5 L 6 5 L 6 5 L 6 5 L 6 5 z ";
const OPERATOR_COLUMN = 1;
const OPERAND_COLUMN = 2;

/**
 * Class CustomExampleProjection provides an entry point for the language engineer to
 * define custom build additions to the editor.
 * These custom build additions are merged with the default and definition-based editor parts
 * in a three-way manner. For each modelelement,
 * (1) if a custom build creator/behavior is present, this is used,
 * (2) if a creator/behavior based on the editor definition is present, this is used,
 * (3) if neither (1) nor (2) yields a result, the default is used.
 */

export class CustomExampleProjection implements FreProjection {
    name: string = "Custom";
    handler: FreProjectionHandler;

    constructor(name?: string) {
        if (!!name) {
            this.name = name;
        }
    }

    nodeTypeToBoxMethod: Map<string, (node: FreNode) => Box> = new Map<string, (node: FreNode) => Box>([
        ["SumExpression", this.createSumBox],
        ["OrExpression", this.createOrBoxGrid],
        ["Documentation", this.createDocumentation],
        // ["Entity", this.createEntity],
        // ["ExampleUnit", this.getUnit],
        ["NumberLiteralExpression", this.createNumberLiteralBox]
    ]);

    nodeTypeToTableDefinition: Map<string, () => FreTableDefinition> = new Map<string, () => FreTableDefinition>([]);

    getTableHeadersFor(projectionName: string): TableRowBox {
        return null;
    }

    ////////////////////////////////////////////////////////////////////
    createNumberLiteralBox(num: NumberLiteralExpression): Box {
        const numBox: Box = BoxUtil.numberBox(num, "value", NumberDisplay.SELECT)
        if (numBox instanceof TextBox) {
            numBox.deleteWhenEmpty = true
        }
        return createDefaultExpressionBox(
            num,
            [numBox],
            { selectable: false },
        );
    }
    
    // createDocumentationD (doc: Documentation): Box {
    //     const result = new DiagramBox(doc, "documentation", "Documentation", "diagram")    
    //     result.addChild(this.createDocumentation(doc))
    //     return result
    // }

    createDocumentation (doc: Documentation): Box {
        return BoxFactory.horizontalLayout(
            doc,
            "Documentation-hlist-line-0",
            "",
            [
                BoxUtil.labelBox(doc, "doc start: ", "top-1-line-0-item-0"),
                // BoxUtil.textBox(this._element as Documentation, "text"),
                new MultiLineTextBox(doc, "exampleunit-documentation",
                    () => { return doc.text},
                    (t: string) => { doc.text = t}
                ),
                BoxUtil.labelBox(doc, ":end doc", "top-1-line-0-item-2")
            ],
            { selectable: false }
        );
    }
    
    createSumBox (sum: SumExpression): Box {
        const cells: GridCellBox[] = [
            new GridCellBox(sum, "Sum-from-cell", 3, 1,
                new HorizontalLayoutBox(sum, "Sum-from-part", [
                    this.optionalPartBox(sum, "SumExpression-variable", "variable"),
                    new LabelBox(sum, "sum-from-equals", "="),
                    this.optionalPartBox(sum, "SumExpression-from", "from")
                ]),
                { columnSpan: 2,
                    cssClass: "mycell"
                }),
            new GridCellBox(sum, "sum-icon-cell", 2, 1,
                new SvgBox(sum, "sum-icon", sumIcon, {
                    viewPortWidth: 50,
                    viewPortHeight: 50,
                    viewBoxWidth: 500,
                    viewBoxHeight: 500,
                    selectable: false
                }),
                { cssClass: "mycell" }
            ),
            new GridCellBox(sum, "sum-to-cell", 1, 1,
                this.optionalPartBox(sum, "SumExpression-to", "to"),
                { columnSpan: 2, cssClass: "mycell" }
            ),
            new GridCellBox(sum, "sum-body-cell", 2, 2,
                new HorizontalListBox(sum, "", "sum-body", [
                    new LabelBox(sum, "sum-body-open", "["),
                    this.optionalPartBox(sum, "SumExpression-body", "body"),
                    new LabelBox(sum, "sum-body-close", "]")
                ]),
                { cssClass: "mycell" }
            )
        ];
        const result = new GridBox(sum, "sum-all", cells, {
            cssClass: "mygrid"
        });
        return createDefaultExpressionBox(sum, [result]);
    }

    public createOrBoxGrid(exp: OrExpression): Box {
        const gridCells: GridCellBox[] = [];
        if (exp.left instanceof OrExpression) {
            gridCells.push(
                new GridCellBox(exp, "or-Box2-cell", 1, OPERATOR_COLUMN,
                    new LabelBox(exp, "or-Box2", () => "or"),
                    { cssClass: "gridCellOr", rowSpan: 3 }
                ),
                new GridCellBox(exp, "orBox3-cell", 1, OPERAND_COLUMN,
                    this.optionalPartBox(exp.left, FRE_BINARY_EXPRESSION_LEFT, "left"),
                    { cssClass: "or_gridcellFirst" }
                ),
                new GridCellBox(exp, "or-Box4-cell", 2, OPERAND_COLUMN,
                    this.optionalPartBox(exp.left, FRE_BINARY_EXPRESSION_RIGHT, "right"),
                    { cssClass: "gridcell" }
                ),
                new GridCellBox(exp, "or-Box5-cell", 3, OPERAND_COLUMN,
                    this.optionalPartBox(exp, FRE_BINARY_EXPRESSION_RIGHT, "right"),
                    { cssClass: "gridcellLast" }
                )
            );
        } else {
            gridCells.push(
                new GridCellBox(exp, "or-Box6-cell", 1, OPERATOR_COLUMN,
                    new LabelBox(exp, "or-Box3", () => "or"),
                    { cssClass: "gridCellOr", rowSpan: 2 }
                ),
                new GridCellBox(exp, "or-Box7-cell", 1, OPERAND_COLUMN,
                    this.optionalPartBox(exp, FRE_BINARY_EXPRESSION_LEFT, "left"),
                    { cssClass: "or_gridcellFirst" }
                ),
                new GridCellBox(exp, "or-Box8-cell", 2, OPERAND_COLUMN,
                    this.optionalPartBox(exp, FRE_BINARY_EXPRESSION_RIGHT, "right"),
                    { cssClass: "gridcellLast" }
                )
            );
        }
        return new GridBox(exp, "grid-or", gridCells,
            { cssClass: "grid" }
        );
    }

    private optionalPartBox(element: FreNode, roleName: string, property: string): Box {
        // const projectionToUse = !!this.rootProjection ? this.rootProjection : this;
        // todo reimplement or rethink this
        return !!element[property]
            ? ExampleEnvironment.getInstance().editor.projection.getBox(element[property])
            : new ActionBox(element,
                roleName,
                "[" + property + "]",
                { propertyName: property, conceptName: FreLanguage.getInstance().classifier(element.freLanguageConcept()).properties.get(property).type });
    }
    
    private createEntity(entity: Entity): Box {
        return BoxFactory.verticalLayout(entity as Entity, "Entity-overall", "", [
            BoxFactory.horizontalLayout(
                entity as Entity,
                "Entity-hlist-line-0",
                "",
                [
                    BoxUtil.booleanBox(entity as Entity, "abstract", { yes: "RIGHT", no: "WRONG" }, BoolDisplay.SELECT),
                    BoxUtil.labelBox(entity as Entity, "entity", "top-1-line-0-item-1"),
                    BoxUtil.textBox(entity as Entity, "name"),
                    BoxFactory.optional2(
                        entity as Entity,
                        "optional-baseEntity",
                        () => !!(entity as Entity).baseEntity,
                        BoxFactory.horizontalLayout(
                            entity as Entity,
                            "Entity-optional-baseEntity-hlist-line-0",
                            "",
                            [
                                BoxUtil.labelBox(entity as Entity, "base", "top-2-line-0-item-0"),
                                BoxUtil.referenceBox(
                                    entity as Entity,
                                    "baseEntity",
                                    (selected: string) => {
                                        (entity as Entity).baseEntity = FreNodeReference.create<Entity>(selected, "Entity");
                                    },
                                    ExampleEnvironment.getInstance().scoper,
                                ),
                            ],
                            { selectable: false },
                        ),
                        false,
                        BoxFactory.action(entity, "optional-baseEntity", "base"),
                    ),
                    BoxFactory.optional2(
                        entity as Entity,
                        "optional-baseInterfaces",
                        () => !!(entity as Entity).baseInterfaces && (entity as Entity).baseInterfaces.length !== 0,
                        BoxFactory.horizontalLayout(
                            entity as Entity,
                            "Entity-optional-baseInterfaces-hlist-line-0",
                            "",
                            [
                                BoxUtil.labelBox(entity as Entity, "implements", "top-2-line-0-item-0"),
                                BoxUtil.verticalReferenceListBox(
                                    entity as Entity,
                                    "baseInterfaces",
                                    ExampleEnvironment.getInstance().scoper,
                                    false,
                                    null,
                                ),
                            ],
                            { selectable: false },
                        ),
                        false,
                        BoxFactory.action(entity, "optional-baseInterfaces", "implements"),
                    ),
                    BoxUtil.labelBox(entity as Entity, "{", "top-1-line-0-item-5"),
                ],
                { selectable: false },
            ),
            new DiagramBox(entity, "attributes", "Attribute", "entityDiagramAttributes", entity.attributes.map(att => this.handler.getBox(att)), []),
            // BoxUtil.indentBox(
            //     entity as Entity,
            //     4,
            //     "1",
            //     BoxUtil.verticalPartListBox(entity as Entity, (entity as Entity).attributes, "attributes", null, this.mainHandler),
            // ),
            BoxUtil.indentBox(
                entity as Entity,
                4,
                "2",
                BoxUtil.verticalPartListBox(entity as Entity, (entity as Entity).methods, "methods", null, this.handler),
            ),
            BoxUtil.labelBox(entity as Entity, "}", "top-1-line-3-item-0")
        ]);
    }

    getUnit(unit: ExampleUnit): Box {
        return BoxFactory.verticalLayout(unit as ExampleUnit, "ExampleUnit-overall", "", [
            BoxUtil.getBoxOrAction(unit as ExampleUnit, "documentation", "Documentation", this.handler),
            BoxFactory.horizontalLayout(
                unit as ExampleUnit,
                "ExampleUnit-hlist-line-1",
                "",
                [
                    BoxUtil.labelBox(unit as ExampleUnit, "unit", "top-1-line-1-item-0"),
                    BoxUtil.textBox(unit as ExampleUnit, "name"),
                    BoxUtil.labelBox(unit as ExampleUnit, "{", "top-1-line-1-item-2"),
                ],
                { selectable: false },
            ),
            BoxUtil.labelBox(unit as ExampleUnit, "}", "top-1-line-6-item-0"),
            this.createDiagramBox(unit, [...unit.entities, ...unit.interfaces])
        ]);
    }
    
    createDiagramBox(unit: ExampleUnit, nodeList: FreNode[]): DiagramBox {
        // map nodelist to 
        const freNodeToBox = new Map<FreNode, Box>()
        nodeList.forEach(node => freNodeToBox.set(node, this.handler.getBox(node)))
        const edges = [] 
        nodeList.filter(node => node instanceof Entity).map(e => {
            const ent = e as Entity
            if (!!ent.baseEntity) {
                edges.push({
                    id: ent.freId() + '-' + ent.baseEntity.referred.freId(),
                    source: ent.freId(),
                    target: ent.baseEntity.referred.freId(),
                    animated: false,
                    type: 'default',
                    style: 'stroke: red'
                })
            }
        })
        return new DiagramBox(unit, "entities", "Entity", "unitDiagramEntities", Array.from(freNodeToBox.values()), edges)
    }
}

